This tutorial will guide you through everything you need to know to build your first Messenger bot. Before you begin, choose one of the options under Starter Projects to get the code you will need to start, then follow the steps under Getting Started to get set up. Before you begin this quick start, make sure you have completed one of the following to ensure you have the starter code you will need. The starter code provides a basic webhook that we will use as the foundation of our Messenger bot. Our webhook setup guide will walk you through building your first webhook that your can use with this quick start from start to finish. Download our webhook starter code from GitHub, and deploy it to a server of your choice. If you do not have a server to deploy your webhook to, you can remix our starter webhook project on Glitch, which will provide a public URL served over HTTPS for your webhook. To create your own webhook on Glitch, do the following: Before you build your first Messenger bot, start by setting up the credentials for your app. If you have not already, follow our app setup guide to set up your Facebook app for use with the Messenger Platform. Until your app has been submitted and approved for public use on Messenger, page tokens only allow your bot to interact with Facebook accounts that have been granted the Administrator, Developer, or Tester role for your app. To grant these roles to other Facebook accounts, go to the 'Roles' tab of your app settings. All requests to Messenger Platform APIs are authenticated by including a page-level access token in the access_token parameter of the query string. If you did not already do so when you set up your Facebook app, generate a page access token, by doing the following: It is recommended that you keep sensitive information like your page access token secure by not hardcoding it into your webhook. To do this, add the following to your environment variables, where <PAGE_ACCESS_TOKEN> is the access token you just generated: If you are using Glitch, set your environment variables in the provided .env file to ensure they are not visible to other Glitch users. Now all you have to do is add your page access token and verify token to your webhook code: 1. Add your page access token to the top of your app.js file: 2. Set your verify token in your webhook verification code: In this tutorial we will build a simple Messenger bot that does the following: Parses the message and sender's page-scoped ID from an incoming webhook event. Handles messages and messaging_postbacks webhook events. Sends messages via the Send API. Responds to text messages with a text message. Responds to an image attachment with a generic template that uses the received image. Responds conditionally to a postback payload. To start, we will stub out three functions that will handle the incoming webhook event types we want to support, as well as responding via the send API. To do this, append the following to your app.js file: To respond to people on Messenger, the first thing we need is to know who they are. In Messenger bot's this is accomplished by getting the message sender's page-scoped ID (PSID) from the incoming webhook event. A person is assigned a unique page-scoped ID (PSID) for each Facebook Page they start a conversation with. The PSID is used by your Messenger bot to identify a person when sending messages. If you completed one of the options in the Requirements section above, you should have a basic /webhook endpoint that accepts POST requests and logs the body of received webhook events that looks like this: To get the sender's PSID, update the body.entry.forEach block with the following code to extract the PSID from the sender.id property of the event: We want our bot to be able to handle two types of webhook events: messages and messaging_postback. The name of the event type is not included in the event body, but we can determine it by checking for certain object properties. The Messenger Platform sends webhook events to notify your Messenger bot of actions that occur in Messenger. Events are sent in JSON format as POST requests to your webhook. For more information, see Webhook Events. To do this, update the body.entry.forEach block of your webhook with a conditional that checks whether the received event contains a message or postback property. We will also add calls to the handleMessage() and handlePostback() functions that we stubbed out earlier: Now that our incoming messages are being routed to the appropriate handler function, we will update handleMessage() to handle and respond to basic text messages. To do this, update the code to define the message payload of our response, then pass that payload to callSendAPI(). We want to respond with a basic text message, so we define a JSON object with a "text" property: Time to send your first message with the Messenger Platform's Send API! In handleMessage(), we are calling callSendAPI() so now we need to update it to construct the full request body and send it to the Messenger Platform. A request to the Send API has two properties: To construct the request body, update the stub for callSendAPI() to the following: Now all we have to do is send our message by submitting a POST request to the Send API at https://graph.facebook.com/v2.6/me/messages. Note that you must append your PAGE_ACCESS_TOKEN in the access_token parameter of the URL query string. In this quick start, we are using the Node.js request module for sending HTTP requests back to the Messenger Platform, but you can use any HTTP client you like. To install the request module, run npm install request --save from the command line, then import it by adding the following to the top of app.js: Since our response prompts the message recipient to send an image, our next step is to update our code to handle an attachment. Sent attachments are automatically saved by the Messenger Platform and made available via a URL in the payload.url property of each index in the attachments array, so we will also extract this from the event. To determine if the message is an attachment, update the conditional in your handleMessage() function to check the received_message for an attachments property, then extract the URL for it. In a real-world bot we would iterate the array to check for multiple attachments, but for the purpose of this quick start, we will just get the first attachment. Next, we will respond to the image with a generic template message. The generic template is the most commonly used structured message type, and allows you to send an image, text, and buttons in one message. Yes! The Messenger Platform provides a set of useful message templates, each designed to support a different, common message structure, including lists, receipts, buttons, and more. For complete details, see Templates. Message templates are defined in the attachment property of the message, which contains type and payload properties. The payload is where we set the details of our generic template in the following properties: For our structured message, we will use the attachment_url that was sent to us as the image_url to display in our template, and include a couple postback buttons to allow the message recipient to respond. To construct the message payload and send the generic template, update handleMessage() to the following: Our last step is to handle the messaging_postbacks webhook event that will be sent when the message recipient taps one of the postback buttons in our generic template. The postback button sends a messaging_postbacks webhook event to your webhook that includes a custom string of up to 1,000 character in the payload property. This allows you to easily implement different postback payloads that you can parse and respond to with specific behaviors. Since our generic template allows the message recipient to choose from two postback buttons, we will respond based on the value of the payload property of the postback event. To do this, update your handlePostback() stub to the following: